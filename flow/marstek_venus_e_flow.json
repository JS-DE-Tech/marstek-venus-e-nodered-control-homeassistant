[{"id":"72d2ab39d59acc33","type":"comment","z":"2323a58d30747a1f","name":"Marstek Venus E","info":"","x":280,"y":120,"wires":[]},{"id":"3d1a5000f7db570c","type":"comment","z":"2323a58d30747a1f","name":"Marstek Venus E - Winterbetrieb","info":"❄️ Winterbetrieb-Logik\n\nAktiviert per Switch „Winterbetrieb“ in HA.\n🔋 Laden:\nWenn\n- Shelly → total_act_power ≤ –200 W (Einspeisung)\n- länger als 60 s\n  ➡ Modus = Auto\n  → Akku lädt automatisch.\n\n🛑 Stoppen:\nWenn\n- VenusE → ongrid_power > 0 (Netzbezug)\n- länger als 30 s\n- und SoC ≤ 50 %\n  ➡ Modus = Passive\n  → Akku entlädt nicht mehr.\n\n(Optional: bei SoC ≥ 80 % ebenfalls Passive, wenn aktiviert.)\n🏠 Home Assistant\n- Schalter: „Winterbetrieb“ (unter Marstek VenusE 3.0)\n- Sensoren: SoC, Netzleistung, Status etc.\n- MQTT-Topics: marstek/venus_e/... & marstek/winter/...\n\n💡 Ergebnis:\nIm Winter lädt der Akku nur bei Überschuss und bleibt bei Netzbezug oder niedrigem SoC passiv – vollautomatisch, gesteuert über einen einzigen Schalter.","x":330,"y":980,"wires":[]},{"id":"b7dae8021f2f4c5e","type":"inject","z":"2323a58d30747a1f","name":"Poll every 2s","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"2","crontab":"","once":true,"onceDelay":"1","topic":"","payload":"","payloadType":"date","x":320,"y":1060,"wires":[["58e6dd86ea6ae62c"]]},{"id":"58e6dd86ea6ae62c","type":"function","z":"2323a58d30747a1f","name":"Build UDP queries (IDs fixed)","func":"// JSON-RPC Requests mit festen IDs\nconst reqs = [\n  { id:100, method:\"Marstek.GetDevice\", params:{ ble_mac:\"0\" } },\n  { id:101, method:\"Wifi.GetStatus\",    params:{ id:0 } },\n  { id:102, method:\"BLE.GetStatus\",     params:{ id:0 } },\n  { id:103, method:\"Bat.GetStatus\",     params:{ id:0 } },\n  { id:104, method:\"ES.GetMode\",        params:{ id:0 } },\n  { id:105, method:\"EM.GetStatus\",      params:{ id:0 } }\n];\nlet out=[];\nfor(const r of reqs){\n  out.push({ payload: Buffer.from(JSON.stringify({id:r.id,method:r.method,params:r.params}),'utf8'), topic:r.method });\n}\nreturn [out];","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1400,"y":1060,"wires":[["440e29182b3a25eb"]]},{"id":"0cadd4b9b7427cdf","type":"udp in","z":"2323a58d30747a1f","name":"UDP ← VenusE (local:30000)","iface":"","port":"30000","ipv":"udp4","multicast":"false","group":"","datatype":"buffer","x":360,"y":200,"wires":[["522a6073a4de3aa9"]]},{"id":"413441b26fcbd76b","type":"function","z":"2323a58d30747a1f","name":"Parse reply + MQTT Discovery/States (marstek/venus_e)","func":"// ===== Parse reply + MQTT Discovery/States (marstek/venus_e) =====\n// INPUTS:\n//   - UDP Antworten vom Speicher (JSON-RPC mit festen IDs 100..105)\n//   - ein künstliches Inject mit topic=\"__discovery__\"\n// OUTPUTS:\n//   output 1 → UDP Requests (normal leer; nur falls Discovery später was triggern müsste)\n//   output 2 → MQTT Discovery configs (retain:true)\n//   output 3 → MQTT State publishes (stat/* Werte)\n//\n// Topics/Prefixes:\n//   discoBase = homeassistant\n//   statBase  = marstek/venus_e/stat\n//   cmndBase  = marstek/venus_e/cmnd\n//\n// Wir announcen hier ALLES zentral:\n//   - Sensors\n//   - Select für Betriebsmodus\n//   - Switch Winterbetrieb\n//   - Switch Lagerungsbetrieb\n//   (separater Discovery-Node nicht mehr nötig)\n\nconst discoBase = 'homeassistant';\nconst devId     = 'marstek_venus_e_v3_UDP';\nconst devName   = 'Marstek VenusE 3.0';\nconst manu      = 'Marstek';\nconst model     = 'VenusE 3.0';\nconst statBase  = 'marstek/venus_e/stat';\nconst cmndBase  = 'marstek/venus_e/cmnd';\n\nfunction T(leaf){ return `${statBase}/${leaf}`; }\nfunction pub(leaf, val){\n    return { topic: T(leaf), payload: String(val) };\n}\n\nif (msg && msg.topic === '__discovery__') {\n    const d = [];\n    const deviceInfo = {\n        identifiers: [devId],\n        manufacturer: manu,\n        model,\n        name: devName\n    };\n\n    const add = (t,p) => d.push({\n        topic: t,\n        payload: JSON.stringify(p),\n        retain: true\n    });\n\n    const S = (oid, name, leaf, unit) => add(\n        `${discoBase}/sensor/${oid}/config`,\n        {\n            name,\n            unique_id: oid,\n            state_topic: `${statBase}/${leaf}`,\n            unit_of_measurement: unit,\n            device: deviceInfo\n        }\n    );\n\n    const SEL = (oid, name, opts, cmdLeaf, stateLeaf) => add(\n        `${discoBase}/select/${oid}/config`,\n        {\n            name,\n            unique_id: oid,\n            command_topic: `${cmndBase}/${cmdLeaf}`,\n            state_topic: `${statBase}/${stateLeaf}`,\n            options: opts,\n            device: deviceInfo\n        }\n    );\n\n    // ---------- Sensoren ----------\n    S('marstek_venus_device',         'Gerät/Modell',            'device');\n    S('marstek_venus_fw_ver',         'Firmware Version',        'fw_ver');\n    S('marstek_venus_ble_mac',        'BLE MAC',                 'ble_mac');\n    S('marstek_venus_wifi_mac',       'WLAN MAC',                'wifi_mac');\n    S('marstek_venus_wifi_ssid',      'WLAN SSID',               'wifi_ssid');\n    S('marstek_venus_wifi_rssi',      'WLAN RSSI',               'wifi_rssi', 'dBm');\n    S('marstek_venus_ble_state',      'BLE Status',              'ble_state');\n    S('marstek_venus_bat_soc',        'Batterie SoC',            'bat_soc', '%');\n    S('marstek_venus_bat_temp_c',     'Batterie Temperatur',     'bat_temp_c', '°C');\n    S('marstek_venus_bat_capacity',   'Verbleibende Kapazität',  'bat_capacity', 'Wh');\n    S('marstek_venus_rated_capacity', 'Nennkapazität',           'rated_capacity', 'Wh');\n    S('marstek_venus_charg_flag',     'Charging erlaubt',        'charg_flag');\n    S('marstek_venus_dischrg_flag',   'Discharge erlaubt',       'dischrg_flag');\n    S('marstek_venus_mode',           'Modus',                   'mode');\n    S('marstek_venus_ongrid_power',   'Netzleistung',            'ongrid_power', 'W');\n    S('marstek_venus_offgrid_power',  'Offgrid-Leistung',        'offgrid_power', 'W');\n    S('marstek_venus_es_bat_soc',     'Batterie SoC (ES)',       'es_bat_soc', '%');\n    S('marstek_venus_total_power',    'Gesamtleistung',          'total_power', 'W');\n    S('marstek_venus_em_ct_state',    'CT Status (EM)',          'em_ct_state');\n    S('marstek_venus_em_a_power',     'EM Phase A',              'em_a_power', 'W');\n    S('marstek_venus_em_b_power',     'EM Phase B',              'em_b_power', 'W');\n    S('marstek_venus_em_c_power',     'EM Phase C',              'em_c_power', 'W');\n    S('marstek_venus_em_total_power', 'EM Gesamtleistung',       'em_total_power', 'W');\n\n    // ---------- Select (Betriebsmodus) ----------\n    SEL(\n        'marstek_venus_mode_select',\n        'Betriebsmodus',\n        ['Auto','AI','Manual','Passive'],\n        'mode',\n        'mode'\n    );\n\n    // ---------- Winterbetrieb-Schalter ----------\n    add(\n        `${discoBase}/switch/marstek_venus_winter_mode_switch/config`,\n        {\n            name: 'Winterbetrieb',\n            unique_id: 'marstek_venus_winter_mode_switch',\n            command_topic: 'marstek/winter/cmnd/winter_mode',\n            payload_on: 'ON',\n            payload_off: 'OFF',\n            state_topic: 'marstek/winter/stat/winter_mode',\n            state_on: 'ON',\n            state_off: 'OFF',\n            icon: 'mdi:snowflake',\n            device: deviceInfo\n        }\n    );\n\n    // ---------- Lagerungsbetrieb-Schalter ----------\n    add(\n        `${discoBase}/switch/marstek_venus_storage_switch/config`,\n        {\n            name: 'Lagerungsbetrieb',\n            unique_id: 'marstek_venus_storage_switch',\n            command_topic: 'marstek/storage/cmnd/enable',\n            payload_on: 'ON',\n            payload_off: 'OFF',\n            state_topic: 'marstek/storage/stat/enable',\n            state_on: 'ON',\n            state_off: 'OFF',\n            icon: 'mdi:battery-clock',\n            device: deviceInfo\n        }\n    );\n\n    return [ null, d, null ];\n}\n\n// ===== echte UDP Antworten vom Speicher =====\nlet txt;\ntry {\n    txt = msg.payload.toString('utf8');\n} catch(e) {\n    return null;\n}\nlet js;\ntry {\n    js = JSON.parse(txt);\n} catch(e) {\n    node.warn('JSON parse error: ' + e);\n    return null;\n}\nif (!js || (!js.result && !js.error)) {\n    return null;\n}\n\nconst out = [];\nif (js.result) {\n    if (js.id === 100) {\n        if (js.result.device      !== undefined) out.push(pub('device',        js.result.device));\n        if (js.result.ver         !== undefined) out.push(pub('fw_ver',        js.result.ver));\n        if (js.result.ble_mac     !== undefined) out.push(pub('ble_mac',       js.result.ble_mac));\n        if (js.result.wifi_mac    !== undefined) out.push(pub('wifi_mac',      js.result.wifi_mac));\n        if (js.result.wifi_name   !== undefined) out.push(pub('wifi_ssid',     js.result.wifi_name));\n    }\n    if (js.id === 101) {\n        if (js.result.ssid        !== undefined) out.push(pub('wifi_ssid',     js.result.ssid));\n        if (js.result.rssi        !== undefined) out.push(pub('wifi_rssi',     js.result.rssi));\n    }\n    if (js.id === 102) {\n        if (js.result.state       !== undefined) out.push(pub('ble_state',     js.result.state));\n        if (js.result.ble_mac     !== undefined) out.push(pub('ble_mac',       js.result.ble_mac));\n    }\n    if (js.id === 103) {\n        const soc = js.result.soc;\n        const tr  = js.result.bat_temp;\n        let tc;\n        if (typeof tr === 'number') {\n            tc = Math.round((tr / 10) * 10) / 10; // Zehntel-°C zu °C mit 1 NK\n        }\n        if (soc                          !== undefined) out.push(pub('bat_soc',        soc));\n        if (tc                           !== undefined) out.push(pub('bat_temp_c',     tc));\n        if (js.result.bat_capacity       !== undefined) out.push(pub('bat_capacity',   js.result.bat_capacity));\n        if (js.result.rated_capacity     !== undefined) out.push(pub('rated_capacity', js.result.rated_capacity));\n        if (js.result.charg_flag         !== undefined) out.push(pub('charg_flag',     js.result.charg_flag));\n        if (js.result.dischrg_flag       !== undefined) out.push(pub('dischrg_flag',   js.result.dischrg_flag));\n    }\n    if (js.id === 104) {\n        if (js.result.mode              !== undefined) out.push(pub('mode',            js.result.mode));\n        if (js.result.ongrid_power      !== undefined) out.push(pub('ongrid_power',    js.result.ongrid_power));\n        if (js.result.offgrid_power     !== undefined) out.push(pub('offgrid_power',   js.result.offgrid_power));\n        if (js.result.bat_soc           !== undefined) out.push(pub('es_bat_soc',      js.result.bat_soc));\n        if (js.result.total_power       !== undefined) out.push(pub('total_power',     js.result.total_power));\n    }\n    if (js.id === 105) {\n        if (js.result.ct_state    !== undefined) out.push(pub('em_ct_state',   js.result.ct_state));\n        if (js.result.a_power     !== undefined) out.push(pub('em_a_power',    js.result.a_power));\n        if (js.result.b_power     !== undefined) out.push(pub('em_b_power',    js.result.b_power));\n        if (js.result.c_power     !== undefined) out.push(pub('em_c_power',    js.result.c_power));\n        if (js.result.total_power !== undefined) out.push(pub('em_total_power',js.result.total_power));\n    }\n}\nreturn [ null, null, out ];","outputs":3,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":1030,"y":420,"wires":[["82cd8fd8b98bb7dd"],["eb14eb2e1b2fc555"],["eb14eb2e1b2fc555"]]},{"id":"9187f6c6f251cb91","type":"inject","z":"2323a58d30747a1f","name":"Publish MQTT Discovery (once)","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":true,"onceDelay":0.2,"topic":"__discovery__","payload":"","payloadType":"date","x":370,"y":420,"wires":[["413441b26fcbd76b"]]},{"id":"3f7ee0de103d2d23","type":"mqtt in","z":"2323a58d30747a1f","name":"cmd: Winterbetrieb","topic":"marstek/winter/cmnd/winter_mode","qos":"0","datatype":"auto","broker":"22f544be.780a3c","inputs":0,"x":330,"y":1180,"wires":[["f31bff547abeb9e3"]]},{"id":"f31bff547abeb9e3","type":"function","z":"2323a58d30747a1f","name":"Switch → flow.winter_enabled + echo","func":"const v = String(msg.payload||'').trim().toUpperCase();\nconst on = (v==='ON'||v==='1'||v==='TRUE');\nflow.set('winter_enabled', on);\n// Trace\nnode.send({ topic:'marstek/winter/stat/trace', payload:`WINTER set to ${on?'ON':'OFF'}` });\n// Echo-State zur Anzeige in HA und als Trigger für Controller\nreturn { topic:'marstek/winter/stat/winter_mode', payload: on?'ON':'OFF' };","outputs":1,"x":770,"y":1180,"wires":[["bcedb2ae17cb9b1a","f436f22a608a5dce"]]},{"id":"0863c0f72952e2fe","type":"mqtt in","z":"2323a58d30747a1f","name":"Shelly: Netz Total Active Power","topic":"shellypro3em-sab7-netz/status/em:0","qos":"0","datatype":"auto","broker":"22f544be.780a3c","inputs":0,"x":370,"y":1240,"wires":[["744d0157cff4bc96"]]},{"id":"744d0157cff4bc96","type":"function","z":"2323a58d30747a1f","name":"parse Shelly → src=surplus","func":"let js;\ntry{\n  js = (typeof msg.payload === 'string') ? JSON.parse(msg.payload) : msg.payload;\n}catch(e){ return null; }\nif(!js || typeof js.total_act_power === 'undefined') return null;\nconst val = Number(js.total_act_power);\nif (isNaN(val)) return null;\nmsg.src = 'surplus';\nmsg.val = val; // + = Netzbezug, - = Einspeisung\nreturn msg;","outputs":1,"x":740,"y":1240,"wires":[["bcedb2ae17cb9b1a"]]},{"id":"86419fe00589f5c1","type":"mqtt in","z":"2323a58d30747a1f","name":"Venus: SoC (stat/es_bat_soc)","topic":"marstek/venus_e/stat/es_bat_soc","qos":"0","datatype":"auto","broker":"22f544be.780a3c","inputs":0,"x":360,"y":1360,"wires":[["2390873a5616ac49"]]},{"id":"68c06dd8fefd2e68","type":"mqtt in","z":"2323a58d30747a1f","name":"Venus: Netzleistung (stat/ongrid_power)","topic":"marstek/venus_e/stat/ongrid_power","qos":"0","datatype":"auto","broker":"22f544be.780a3c","inputs":0,"x":390,"y":1420,"wires":[["e94572df3cac2150"]]},{"id":"bcedb2ae17cb9b1a","type":"function","z":"2323a58d30747a1f","name":"WINTER Controller (Shelly→Auto, ongrid→Passive)","func":"// ===== WINTER Controller v2.3 (bereinigt, schreibt in marstek.log) =====\n// Output 1: MQTT  (Status / Events / History / und Mode-Befehle an marstek/venus_e/cmnd/mode)\n// Output 2: File  (Logzeile pro Ereignis)\n//\n// Logik Winterbetrieb (wenn aktiv UND keine Lagerung läuft):\n// - Bei PV-Überschuss stabil genug  -> WINTER → AUTO  (Akku darf laden selbständig)\n// - Bei Netzbezug & niedrigem SoC   -> WINTER → PASSIVE (Akku soll nicht ins Haus entladen)\n//\n// NEU: Wenn Lagerungsbetrieb aktiv ist (storage_active=true), dann\n// - macht dieser Node GAR NICHTS\n// - kein AUTO, kein PASSIVE, keine Timer\n// - Statusanzeige wird blau mit Hinweis \"[PAUSE wg. Lagerung]\"\n//\n// Zustände im flow-Kontext:\n//   winter_enabled  (bool)\n//   storage_active  (bool)\n//   soc             (Number, %)\n//   surplus         (Number, W)\n//   vgrid           (Number, W)\n//   tStart, tStop, mute_until\n//   winter_log      (Array<String>)\n\nconst LOG_TOPIC = 'marstek/winter/stat/log';\nconst LOG_HISTORY_TOPIC = LOG_TOPIC + '/history';\n\nconst SURPLUS_START_W   = -200;\nconst SURPLUS_FOR_MS    = 30000;\nconst VGRID_STOP_W      = 100;\nconst STOP_FOR_MS       = 30000;\nconst STOP_FAST_MS      = 5000;\nconst MIN_SOC           = 50;\nconst FAST_SOC_LIMIT    = 41;\nconst PASSIVE_COOLDOWN_MS = 60000;\n\nfunction pushLog(mqttArr, fileArr, logsArr, line) {\n    const entry = `[${new Date().toISOString()}] ${line}`;\n    logsArr.push(entry);\n    mqttArr.push({ topic: LOG_TOPIC, payload: entry });\n    fileArr.push({ payload: entry });\n}\n\nconst enabled       = flow.get('winter_enabled') || false;\nconst storageActive = flow.get('storage_active') || false;\n\nlet soc       = flow.get('soc');\nlet surplus   = flow.get('surplus');\nlet vgrid     = flow.get('vgrid');\nlet tStart    = flow.get('tStart');\nlet tStop     = flow.get('tStop');\nlet muteUntil = flow.get('mute_until') || 0;\n\nif (msg.src === 'soc')        { soc     = Number(msg.val); flow.set('soc', soc); }\nif (msg.src === 'surplus')    { surplus = Number(msg.val); flow.set('surplus', surplus); }\nif (msg.src === 'venus_grid') { vgrid   = Number(msg.val); flow.set('vgrid', vgrid); }\n\nconst now      = Date.now();\nconst mqttOut  = [];\nconst fileOut  = [];\nconst logsBuf  = [];\n\n// Lagerung hat Vorrang: dann NICHTS machen\nif (storageActive) {\n    flow.set('tStart', null);\n    flow.set('tStop',  null);\n    node.status({\n        fill: 'blue',\n        shape: 'dot',\n        text: `[PAUSE wg. Lagerung] soc=${soc ?? '—'} | vgrid=${vgrid ?? '—'}`\n    });\n    return null;\n}\n\n// Status anzeigen\nnode.status({\n    fill: enabled ? 'green' : 'grey',\n    shape: 'dot',\n    text: `[WINTER=${enabled ? 'ON' : 'OFF'}] soc=${soc ?? '—'} | vgrid=${vgrid ?? '—'} | surplus=${surplus ?? '—'}`\n});\n\nif (!enabled) {\n    flow.set('tStart', null);\n    flow.set('tStop',  null);\n    return null;\n}\n\n// ====== PASSIVE anfordern bei Netzbezug & niedrigem SoC ======\nif (typeof vgrid === 'number' && typeof soc === 'number' && soc <= MIN_SOC) {\n    if (vgrid >= VGRID_STOP_W) {\n        if (!tStop) { tStop = now; flow.set('tStop', tStop); }\n        const stopDelay = (soc < FAST_SOC_LIMIT) ? STOP_FAST_MS : STOP_FOR_MS;\n        const dt = now - tStop;\n\n        node.status({\n            fill: 'yellow',\n            shape: 'dot',\n            text: `[STOPCHK] ongrid=${Math.round(vgrid)}W SoC=${soc}% ${(dt / 1000).toFixed(1)}/${stopDelay / 1000}s`\n        });\n\n        if (dt >= stopDelay) {\n            pushLog(mqttOut, fileOut, logsBuf, `WINTER → PASSIVE (ongrid=${Math.round(vgrid)}W, SoC=${soc}%)`);\n            mqttOut.push({ topic: 'marstek/venus_e/cmnd/mode', payload: 'Passive' });\n            flow.set('mute_until', now + PASSIVE_COOLDOWN_MS);\n            flow.set('tStart', null);\n            flow.set('tStop',  null);\n            node.status({ fill: 'red', shape: 'ring', text: `PASSIVE sent (${Math.round(vgrid)}W)` });\n        }\n    } else { flow.set('tStop', null); tStop = null; }\n} else { flow.set('tStop', null); tStop = null; }\n\n// ====== AUTO anfordern bei stabiler Einspeisung ======\nconst mayStartAuto = (typeof vgrid !== 'number') ? true : (vgrid <= 0);\nif (typeof surplus === 'number' && mayStartAuto) {\n    if (now >= muteUntil) {\n        if (surplus <= SURPLUS_START_W) {\n            if (!tStart) { tStart = now; flow.set('tStart', tStart); }\n            const dt = now - tStart;\n\n            node.status({\n                fill: 'green',\n                shape: 'dot',\n                text: `[AUTOCHK] surplus=${Math.round(surplus)}W ${(dt / 1000).toFixed(1)}/${SURPLUS_FOR_MS / 1000}s`\n            });\n\n            if (dt >= SURPLUS_FOR_MS) {\n                pushLog(mqttOut, fileOut, logsBuf, `WINTER → AUTO (Einspeisung=${Math.round(surplus)}W)`);\n                mqttOut.push({ topic: 'marstek/venus_e/cmnd/mode', payload: 'Auto' });\n                flow.set('tStop',  null);\n                flow.set('tStart', null);\n                node.status({ fill: 'green', shape: 'ring', text: 'AUTO sent' });\n            }\n        } else { flow.set('tStart', null); tStart = null; }\n    } else {\n        node.status({\n            fill: 'grey',\n            shape: 'dot',\n            text: `[MUTE] AUTO blockiert noch ${((muteUntil - now) / 1000).toFixed(0)}s`\n        });\n        flow.set('tStart', null);\n        tStart = null;\n    }\n} else { flow.set('tStart', null); tStart = null; }\n\n// ====== History puffern (max 20) & als JSON via MQTT ======\nif (logsBuf.length) {\n    const stored = flow.get('winter_log') || [];\n    for (const line of logsBuf) stored.push(line);\n    while (stored.length > 20) stored.shift();\n    flow.set('winter_log', stored);\n\n    mqttOut.push({\n        topic: LOG_HISTORY_TOPIC,\n        payload: JSON.stringify(stored, null, 2)\n    });\n}\n\nif (mqttOut.length || fileOut.length) return [mqttOut, fileOut];\nreturn null;","outputs":2,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":1320,"y":1240,"wires":[["f436f22a608a5dce"],["2a278b0892f5d734"]]},{"id":"f436f22a608a5dce","type":"mqtt out","z":"2323a58d30747a1f","name":"MQTT publish","topic":"","qos":"","retain":"","broker":"22f544be.780a3c","x":1820,"y":1180,"wires":[]},{"id":"9c6da8e4d3b7610b","type":"debug","z":"2323a58d30747a1f","name":"DBG ongrid payload","active":false,"tosidebar":false,"console":false,"tostatus":true,"complete":"payload","targetType":"msg","statusVal":"payload","statusType":"auto","x":1840,"y":1420,"wires":[]},{"id":"aa34bf1563b9ddf0","type":"mqtt in","z":"2323a58d30747a1f","name":"cmd: mode select (optional)","topic":"marstek/venus_e/cmnd/mode","qos":"0","datatype":"auto","broker":"22f544be.780a3c","inputs":0,"x":360,"y":1120,"wires":[["0882890d778460f9"]]},{"id":"0882890d778460f9","type":"function","z":"2323a58d30747a1f","name":"ES.SetMode (UDP) + optimistic state","func":"// Normalisieren der gewünschten Eingabe (ON/AUTO/etc.)\nlet raw = String(msg.payload ?? \"\").trim();\nconst up = raw.toUpperCase();\n\nif (up === \"ON\" || up === \"AUTO\") {\n    raw = \"Auto\";\n} else if (up === \"OFF\" || up === \"PASSIVE\" || up === \"STANDBY\") {\n    raw = \"Passive\";\n}\n\nconst mode = raw; // \"Auto\", \"Passive\", \"Manual\", \"AI\", ...\n\nfunction build(m) {\n    if (m === \"Auto\") {\n        return {\n            id: 310,\n            method: \"ES.SetMode\",\n            params: {\n                id: 0,\n                config: {\n                    mode: \"Auto\",\n                    auto_cfg: { enable: 1 }\n                }\n            }\n        };\n    }\n    if (m === \"AI\") {\n        return {\n            id: 311,\n            method: \"ES.SetMode\",\n            params: {\n                id: 0,\n                config: {\n                    mode: \"AI\",\n                    ai_cfg: { enable: 1 }\n                }\n            }\n        };\n    }\n    if (m === \"Manual\") {\n        return {\n            id: 312,\n            method: \"ES.SetMode\",\n            params: {\n                id: 0,\n                config: {\n                    mode: \"Manual\",\n                    manual_cfg: {\n                        time_num: 1,\n                        start_time: \"00:00\",\n                        end_time: \"23:59\",\n                        week_set: 127,\n                        power: -500,\n                        enable: 1\n                    }\n                }\n            }\n        };\n    }\n    return {\n        id: 313,\n        method: \"ES.SetMode\",\n        params: {\n            id: 0,\n            config: {\n                mode: \"Passive\",\n                passive_cfg: {\n                    power: 0,\n                    cd_time: 300\n                }\n            }\n        }\n    };\n}\n\nconst cmd = build(mode);\nconst out1 = {\n    payload: Buffer.from(JSON.stringify(cmd), \"utf8\")\n};\n\nconst mqtt = [\n    {\n        topic: \"marstek/venus_e/stat/mode\",\n        payload: mode\n    }\n];\n\nsetTimeout(() => {\n    const getCmd = {\n        id: 320,\n        method: \"ES.GetMode\",\n        params: { id: 0 }\n    };\n    node.send([\n        [{ payload: Buffer.from(JSON.stringify(getCmd), \"utf8\") }],\n        null\n    ]);\n}, 400);\n\nnode.send([\n    [out1],\n    null\n]);\n\nnode.send([\n    null,\n    mqtt\n]);\n\nreturn null;","outputs":2,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":1370,"y":1120,"wires":[["440e29182b3a25eb"],["f436f22a608a5dce"]]},{"id":"cd046bbca44b1231","type":"udp out","z":"2323a58d30747a1f","name":"UDP → VenusE","addr":"10.100.1.227","iface":"","port":"30000","ipv":"udp4","outport":"","base64":false,"multicast":"false","x":1820,"y":220,"wires":[]},{"id":"2390873a5616ac49","type":"function","z":"2323a58d30747a1f","name":"src=soc, val=Number(payload) (safe)","func":"const v = Number(msg.payload);\nif (Number.isNaN(v)) return null;\nmsg.src = 'soc';\nmsg.val = v;\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":770,"y":1360,"wires":[["bcedb2ae17cb9b1a"]]},{"id":"e94572df3cac2150","type":"function","z":"2323a58d30747a1f","name":"src=venus_grid, val=Number(payload) (safe)","func":"const v = Number(msg.payload);\nif (Number.isNaN(v)) return null;\nmsg.src = 'venus_grid';\nmsg.val = v;\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":790,"y":1420,"wires":[["bcedb2ae17cb9b1a","9c6da8e4d3b7610b"]]},{"id":"959fa15ef467bc36","type":"comment","z":"2323a58d30747a1f","name":"Marstek Venus E - Datenerfassung","info":"","x":340,"y":1580,"wires":[]},{"id":"e81cd44537bd38cc","type":"mqtt in","z":"2323a58d30747a1f","name":"VenusE stat/# (nur ausgewählte Felder)","topic":"marstek/venus_e/stat/#","qos":"0","datatype":"auto","broker":"22f544be.780a3c","nl":false,"rap":true,"rh":0,"inputs":0,"x":390,"y":1640,"wires":[["cd8134414c21ce94"]]},{"id":"0c54cdc2de66602b","type":"influxdb out","z":"2323a58d30747a1f","influxdb":"57c7572eb86c50c7","name":"NodeRed DB - Energiespeicher","measurement":"energiespeicher","precision":"ms","retentionPolicy":"","database":"nodered","precisionV18FluxV20":"ms","retentionPolicyV18Flux":"","org":"","bucket":"","x":1870,"y":1640,"wires":[]},{"id":"cd8134414c21ce94","type":"function","z":"2323a58d30747a1f","name":"→ Influx: Feldnamen direkt aus Topics","func":"// --- Nur diese Keys loggen ---\nconst ALLOWED = new Set([\n  'bat_soc', 'em_ct_state', 'em_total_power', 'bat_temp_c', 'bat_capacity', 'rated_capacity',\n  'charg_flag', 'dischrg_flag', 'ongrid_power', 'offgrid_power', 'es_bat_soc', 'fw_ver'\n]);\n\nconst leaf = String(msg.topic || '').split('/').pop();\nif (!ALLOWED.has(leaf)) return null;\n\n// --- Wert umwandeln ---\nlet val = msg.payload;\nif (leaf === 'charg_flag' || leaf === 'dischrg_flag') {\n  if (typeof val === 'boolean') val = val ? 1 : 0;\n  else {\n    const s = String(val).trim().toLowerCase();\n    if (['true','on','1'].includes(s)) val = 1;\n    else if (['false','off','0'].includes(s)) val = 0;\n    else val = Number(s);\n  }\n} else {\n  const n = Number(val);\n  if (Number.isFinite(n)) val = n; else {\n    const n2 = Number(String(val).replace(/[^-\\d.]/g, ''));\n    if (!Number.isFinite(n2)) return null;\n    val = n2;\n  }\n}\n\nmsg.payload = {};\nmsg.payload[leaf] = val;\nmsg.tags = { device_id: 'marstek_venus_e_v3_UDP' };\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":770,"y":1640,"wires":[["0c54cdc2de66602b"]]},{"id":"4d2758ad4fcbe3f7","type":"inject","z":"2323a58d30747a1f","name":"TEST: Shelly Einspeisung −300 W","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"shellypro3em-sab7-netz/status/em:0","payload":"{\"total_act_power\": -300}","payloadType":"json","x":380,"y":1300,"wires":[["744d0157cff4bc96"]]},{"id":"31aebc4591d2b2f5","type":"mqtt in","z":"2323a58d30747a1f","name":"stat/mode","topic":"marstek/venus_e/stat/mode","qos":"0","datatype":"auto","broker":"22f544be.780a3c","nl":false,"rap":true,"rh":0,"inputs":0,"x":300,"y":1900,"wires":[["ed1e05389d3a0e62"]]},{"id":"88a8bba1ed0b4bb0","type":"mqtt in","z":"2323a58d30747a1f","name":"cmnd/mode","topic":"marstek/venus_e/cmnd/mode","qos":"0","datatype":"auto","broker":"22f544be.780a3c","nl":false,"rap":true,"rh":0,"inputs":0,"x":310,"y":1960,"wires":[["ed1e05389d3a0e62"]]},{"id":"a540edf81065b727","type":"mqtt in","z":"2323a58d30747a1f","name":"stat/storage_info","topic":"marstek/venus_e/stat/storage_info","qos":"0","datatype":"auto","broker":"22f544be.780a3c","nl":false,"rap":true,"rh":0,"inputs":0,"x":320,"y":2020,"wires":[["ed1e05389d3a0e62"]]},{"id":"179d5fa7a7e579f3","type":"mqtt in","z":"2323a58d30747a1f","name":"winter_mode","topic":"marstek/winter/stat/winter_mode","qos":"0","datatype":"auto","broker":"22f544be.780a3c","nl":false,"rap":true,"rh":0,"inputs":0,"x":310,"y":2080,"wires":[["ed1e05389d3a0e62"]]},{"id":"ed1e05389d3a0e62","type":"function","z":"2323a58d30747a1f","name":"Status→Log (to /homeassistant/node-red/marstek.log)","func":"// ===== Status→Log (to file) v1.0 =====\n// Schreibt eine Zeile pro Ereignis in die Logdatei (via File-Node)\n// Erwartete Inputs (alle via MQTT-In an diesen Node):\n//  - marstek/venus_e/stat/mode           -> tatsächlicher Gerätemodus\n//  - marstek/venus_e/cmnd/mode           -> manuelle/HA-Befehle\n//  - marstek/venus_e/stat/storage_info   -> Storage-Ereignisse\n//  - marstek/winter/stat/winter_mode     -> Winterbetrieb ON/OFF\n\nconst TOPIC_MODE_STAT   = 'marstek/venus_e/stat/mode';\nconst TOPIC_MODE_CMND   = 'marstek/venus_e/cmnd/mode';\nconst TOPIC_STORAGE_INFO= 'marstek/venus_e/stat/storage_info';\nconst TOPIC_WINTER_STAT = 'marstek/winter/stat/winter_mode';\n\nconst now = Date.now();\nconst tISO = () => new Date().toISOString();\n\nfunction line(s){ return { payload: `[${tISO()}] ${s}` }; }\n\nconst topic = String(msg.topic || '');\nconst payloadStr = String(msg.payload ?? '').trim();\n\nswitch (topic) {\n  case TOPIC_MODE_STAT: {\n    const newMode = payloadStr || '—';\n    const lastMode = flow.get('log_last_mode');\n    if (lastMode === undefined) {\n      flow.set('log_last_mode', newMode);\n      return line(`MODE init: ${newMode}`);\n    }\n    if (newMode !== lastMode) {\n      const lastCmd = flow.get('log_last_cmd') || null;\n      let reason = '';\n      if (lastCmd && (now - lastCmd.t) <= 5000) reason = ` (cause=cmd:${lastCmd.mode})`;\n      flow.set('log_last_mode', newMode);\n      return line(`MODE: ${lastMode} -> ${newMode}${reason}`);\n    }\n    return null;\n  }\n\n  case TOPIC_MODE_CMND: {\n    flow.set('log_last_cmd', { mode: payloadStr || '—', t: now });\n    return line(`CMD: request ${payloadStr || '—'}`);\n  }\n\n  case TOPIC_STORAGE_INFO: {\n    return line(`STORAGE: ${payloadStr || '—'}`);\n  }\n\n  case TOPIC_WINTER_STAT: {\n    const newState = (payloadStr.toUpperCase()==='ON') ? 'ON' : 'OFF';\n    const lastState = flow.get('log_last_winter');\n    if (lastState === undefined) {\n      flow.set('log_last_winter', newState);\n      return line(`WINTER init: ${newState}`);\n    }\n    if (newState !== lastState) {\n      flow.set('log_last_winter', newState);\n      return line(`WINTER: ${lastState} -> ${newState}`);\n    }\n    return null;\n  }\n\n  default:\n    return null;\n}\n","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":820,"y":2080,"wires":[["0a9a4d91bcf5abfb"]]},{"id":"0a9a4d91bcf5abfb","type":"file","z":"2323a58d30747a1f","name":"marstek.log","filename":"/homeassistant/node-red/marstek.log","filenameType":"str","appendNewline":true,"createDir":true,"overwriteFile":"false","encoding":"none","x":1810,"y":2080,"wires":[[]]},{"id":"e2fa69c32dbbb419","type":"inject","z":"2323a58d30747a1f","name":"Trim alle 10 min","props":[],"repeat":"600","crontab":"","once":true,"onceDelay":"5","topic":"","x":330,"y":1760,"wires":[["0f0e9dccb31d1923"]]},{"id":"0f0e9dccb31d1923","type":"file in","z":"2323a58d30747a1f","name":"read marstek.log","filename":"/homeassistant/node-red/marstek.log","format":"utf8","chunk":false,"sendError":false,"encoding":"none","x":710,"y":1760,"wires":[["74d171385c1538eb"]]},{"id":"74d171385c1538eb","type":"function","z":"2323a58d30747a1f","name":"FIFO: letzte 1000 Zeilen behalten","func":"// Liest gesamten Dateiinhalt (utf8), behält die letzten 1000 Zeilen\n// Wenn <=1000 Zeilen, keine Aktion\n\nconst MAX = 1000;\nconst text = typeof msg.payload === 'string' ? msg.payload : '';\nif (!text) return null;\n\nconst lines = text.split(/\\r?\\n/).filter(l => l.trim() !== '');\nif (lines.length <= MAX) return null;\n\nconst trimmed = lines.slice(-MAX).join('\\n') + '\\n';\nmsg.payload = trimmed;\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1000,"y":1760,"wires":[["868baf74c19ae646"]]},{"id":"868baf74c19ae646","type":"file","z":"2323a58d30747a1f","name":"overwrite → marstek.log (FIFO)","filename":"/homeassistant/node-red/marstek.log","filenameType":"str","appendNewline":false,"createDir":true,"overwriteFile":"true","encoding":"none","x":1870,"y":1760,"wires":[[]]},{"id":"420b9593c07b7fc7","type":"inject","z":"2323a58d30747a1f","name":"Poll every 2s","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"2","crontab":"","once":true,"onceDelay":"1","topic":"","payload":"","payloadType":"date","x":320,"y":300,"wires":[["fb93e8809de278a9"]]},{"id":"fb93e8809de278a9","type":"function","z":"2323a58d30747a1f","name":"Build UDP queries (IDs fixed)","func":"// JSON-RPC Requests mit festen IDs\nconst reqs = [\n  { id:100, method:\"Marstek.GetDevice\", params:{ ble_mac:\"0\" } },\n  { id:101, method:\"Wifi.GetStatus\",    params:{ id:0 } },\n  { id:102, method:\"BLE.GetStatus\",     params:{ id:0 } },\n  { id:103, method:\"Bat.GetStatus\",     params:{ id:0 } },\n  { id:104, method:\"ES.GetMode\",        params:{ id:0 } },\n  { id:105, method:\"EM.GetStatus\",      params:{ id:0 } }\n];\n\nlet out = [];\nfor (const r of reqs){\n  out.push({\n    payload: Buffer.from(JSON.stringify({id:r.id, method:r.method, params:r.params}), 'utf8'),\n    topic: r.method\n  });\n}\nreturn [out];","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":940,"y":300,"wires":[["82cd8fd8b98bb7dd"]]},{"id":"eb14eb2e1b2fc555","type":"mqtt out","z":"2323a58d30747a1f","name":"MQTT publish","topic":"","qos":"","retain":"","respTopic":"","contentType":"","userProps":"","correl":"","expiry":"","broker":"22f544be.780a3c","x":1820,"y":720,"wires":[]},{"id":"1fe90c878ac28db5","type":"mqtt in","z":"2323a58d30747a1f","name":"cmd: mode select","topic":"marstek/venus_e/cmnd/mode","qos":"0","datatype":"auto","broker":"22f544be.780a3c","nl":false,"rap":true,"rh":0,"inputs":0,"x":320,"y":480,"wires":[["a04bbb95cf52c6e4"]]},{"id":"a04bbb95cf52c6e4","type":"function","z":"2323a58d30747a1f","name":"Build ES.SetMode + cancel storage + Manual0 (2 out + optimistic)","func":"// ===== Build ES.SetMode + cancel storage + Manual0 (2 out + optimistic) =====\n// Input: msg.payload = gewünschter Modus (z.B. \"Auto\", \"Passive\", \"Manual0\", \"Manual\", \"AI\", etc.)\n// Output 1: UDP Frame (Buffer) → LinkOut → UDP\n// Output 2: MQTT Messages (Array) → MQTT out\n//\n// - \"Manual0\": Leistung 0W halten, Lagerung abbrechen\n// - \"Passive\": klassisch Passive\n// - \"Auto\" / \"AI\" / \"Manual\": entsprechende Modi\n//\n// Optimistic state publish + optional Lagerungs-Stop.\n\nlet raw = String(msg.payload ?? \"\").trim();\nconst up = raw.toUpperCase();\n\nif (up === \"ON\" || up === \"AUTO\") raw = \"Auto\";\nelse if (up === \"OFF\" || up === \"PASSIVE\" || up === \"STANDBY\") raw = \"Passive\";\nif (up === \"MANUAL0\" || up === \"STOP\" || up === \"0W\") raw = \"Manual0\";\n\nconst wantedMode = raw;\n\nfunction buildModeCmd(which) {\n    if (which === \"Manual0\") {\n        return {\n            id: 912,\n            method: \"ES.SetMode\",\n            params: {\n                id: 0,\n                config: {\n                    mode: \"Manual\",\n                    manual_cfg: {\n                        time_num: 1,\n                        start_time: \"00:00\",\n                        end_time: \"23:59\",\n                        week_set: 127,\n                        power: 0,\n                        enable: 1\n                    }\n                }\n            }\n        };\n    }\n    if (which === \"Manual\") {\n        return {\n            id: 312,\n            method: \"ES.SetMode\",\n            params: {\n                id: 0,\n                config: {\n                    mode: \"Manual\",\n                    manual_cfg: {\n                        time_num: 1,\n                        start_time: \"00:00\",\n                        end_time: \"23:59\",\n                        week_set: 127,\n                        power: -500,\n                        enable: 1\n                    }\n                }\n            }\n        };\n    }\n    if (which === \"Auto\") {\n        return {\n            id: 813,\n            method: \"ES.SetMode\",\n            params: {\n                id: 0,\n                config: {\n                    mode: \"Auto\",\n                    auto_cfg: { enable: 1 }\n                }\n            }\n        };\n    }\n    if (which === \"AI\") {\n        return {\n            id: 311,\n            method: \"ES.SetMode\",\n            params: {\n                id: 0,\n                config: {\n                    mode: \"AI\",\n                    ai_cfg: { enable: 1 }\n                }\n            }\n        };\n    }\n    return {\n        id: 814,\n        method: \"ES.SetMode\",\n        params: {\n            id: 0,\n            config: {\n                mode: \"Passive\",\n                passive_cfg: {\n                    power: 0,\n                    cd_time: 300\n                }\n            }\n        }\n    };\n}\n\nconst cmd = buildModeCmd(wantedMode);\nconst udpOutMsg = {\n    payload: Buffer.from(JSON.stringify(cmd), \"utf8\")\n};\n\nconst mqttOutArr = [];\nlet optimisticModeForMqtt;\nif (wantedMode === \"Manual0\") {\n    optimisticModeForMqtt = \"Manual\"; // für 0-W-Hold\n} else {\n    optimisticModeForMqtt = wantedMode;\n}\n\nif (wantedMode === \"Manual0\") {\n    flow.set(\"storage_active\", false);\n    mqttOutArr.push({\n        topic: \"marstek/venus_e/stat/storage_info\",\n        payload: `storage:abort via Manual0`\n    });\n}\n\nmqttOutArr.push({\n    topic: \"marstek/venus_e/stat/mode\",\n    payload: optimisticModeForMqtt\n});\n\nmqttOutArr.push({\n    topic: \"marstek/venus_e/stat/watchdog_event\",\n    payload: `[${new Date().toISOString()}] CMD: request ${wantedMode}`\n});\n\nsetTimeout(() => {\n    const getCmd = {\n        id: 320,\n        method: \"ES.GetMode\",\n        params: { id: 0 }\n    };\n    const udpGet = {\n        payload: Buffer.from(JSON.stringify(getCmd), \"utf8\")\n    };\n    node.send([[udpGet], null]);\n}, 400);\n\nreturn [\n    [udpOutMsg],\n    mqttOutArr\n];","outputs":2,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":1060,"y":480,"wires":[["82cd8fd8b98bb7dd"],["eb14eb2e1b2fc555"]]},{"id":"f1ea34dee1ba75fd","type":"mqtt in","z":"2323a58d30747a1f","name":"cmd: storage (Button)","topic":"marstek/storage/cmnd/enable","qos":"0","datatype":"auto","broker":"22f544be.780a3c","nl":false,"rap":true,"rh":0,"inputs":0,"x":340,"y":540,"wires":[["a44b197f59436b03"]]},{"id":"3f9d7020d4baf5d5","type":"mqtt in","z":"2323a58d30747a1f","name":"listen: bat_soc","topic":"marstek/venus_e/stat/bat_soc","qos":"0","datatype":"auto","broker":"22f544be.780a3c","nl":false,"rap":true,"rh":0,"inputs":0,"x":310,"y":600,"wires":[["0ec8eee2102c62b8"]]},{"id":"4eb63b8f510eb6ee","type":"mqtt in","z":"2323a58d30747a1f","name":"listen: es_bat_soc (zusätzlich)","topic":"marstek/venus_e/stat/es_bat_soc","qos":"0","datatype":"auto","broker":"22f544be.780a3c","nl":false,"rap":true,"rh":0,"inputs":0,"x":360,"y":660,"wires":[["0ec8eee2102c62b8"]]},{"id":"9a80071861055d84","type":"mqtt in","z":"2323a58d30747a1f","name":"listen: mode → Lagerung abbrechen","topic":"marstek/venus_e/stat/mode","qos":"0","datatype":"auto","broker":"22f544be.780a3c","nl":false,"rap":true,"rh":0,"inputs":0,"x":380,"y":720,"wires":[["29ec6d2b2179c3ed","84fdc643b39d1f50"]]},{"id":"29ec6d2b2179c3ed","type":"function","z":"2323a58d30747a1f","name":"Abbruch wenn Mode ≠ Manual","func":"// Lagerungs-/Grace-Controller v4\n// Eingabe: jedes Update von marstek/venus_e/stat/mode\n//\n// Output[0] -> UDP (Array von { payload: Buffer(JSON.stringify(cmd)) })\n// Output[1] -> MQTT (Array von { topic, payload })\n//\n// Ziele dieser Version:\n// 1. Während Hauptladephase (\"pre-grace\", Ziel-SoC noch nicht erreicht):\n//    - Lagerung soll WEITERLAUFEN und aktiv -500 W forcen, wenn die Venus E\n//      vorzeitig in Passive springt. Also NICHT mehr sofort abbrechen.\n//    - Abbruch passiert nur noch, wenn du Lagerung OFF schaltest (das macht der andere Node),\n//      oder wenn später Grace sauber beendet wird.\n// 2. Während Grace-Phase (\"grace\", also Nachlauf zum Halten auf Ziel-SoC):\n//    - Wir halten mit -250 W und reasserten immer wieder Manual(-250 W),\n//      falls die Venus E rausfliegt.\n// 3. Nach Grace-Ende:\n//    - wir schließen Lagerung sauber, setzen storage_active=false,\n//      MQTT -> OFF, Mode=Passive für HA.\n// 4. Wir loggen über storage_info, was passiert.\n//\n// Erwartete flow-Variablen (werden von anderen Nodes gepflegt):\n//   storage_active          (bool)   -> Lagerung soll laufen (oder Grace läuft noch aktiv)\n//   storage_target          (Number) -> Ziel-SoC nur fürs Logging\n//   storage_grace_until     (ms ts)  -> Ende der Grace-Phase (0 = keine Grace aktiv)\n//   storage_grace_mode250   (bool)   -> true sobald Grace gestartet wurde (Halteleistung -250W)\n//\n// Konstante Ladeleistungen:\nconst POWER_PRE_GRACE_W   = -500; // schnelles Laden bis Ziel-SoC erreicht ist\nconst POWER_GRACE_HOLD_W  = -250; // sanft halten in Grace\n\n// kleine Helfer\nfunction mqttMsg(topic, payload){\n    return { topic, payload };\n}\n\nfunction buildManualCmd(powerW){\n    return {\n        id: 910,\n        method: \"ES.SetMode\",\n        params: {\n            id: 0,\n            config: {\n                mode: \"Manual\",\n                manual_cfg: {\n                    time_num: 1,\n                    start_time: \"00:00\",\n                    end_time: \"23:59\",\n                    week_set: 127,\n                    power: powerW,\n                    enable: 1\n                }\n            }\n        }\n    };\n}\n\nfunction setStatus(fill, shape, text){\n    node.status({ fill, shape, text });\n}\n\n// -----------------------------------------------------------------------\n// Hauptlogik\n// -----------------------------------------------------------------------\nconst modeRaw   = String(msg.payload || \"\").trim();   // z.B. \"Manual\", \"Passive\"\nconst modeLower = modeRaw.toLowerCase();\n\nconst now                = Date.now();\nlet   storageActive      = flow.get(\"storage_active\")      || false;\nlet   graceUntil         = flow.get(\"storage_grace_until\") || 0;\nconst graceMode250       = flow.get(\"storage_grace_mode250\") || false;\nconst targetSoc          = flow.get(\"storage_target\")      || \"?\";\n\nlet udpOutArr  = [];\nlet mqttOutArr = [];\n\n// 0) Falls komplett inaktiv (keine Lagerung und keine Grace geplant)\n//    -> nichts tun.\nif (!storageActive && !graceUntil){\n    setStatus(\"grey\", \"ring\", `idle (mode=${modeRaw})`);\n    return null;\n}\n\n// 1) Sind wir in Grace?\n//    inGrace bedeutet: Grace läuft noch (now < graceUntil) UND wurde schon gestartet\nconst inGrace = (graceUntil && now < graceUntil);\n\n// 2) Grace ist vorbei?\nconst graceFinished = (graceUntil && now >= graceUntil);\n\n// CASE C: Grace fertig -> sauberer Abschluss\n// -----------------------------------------\nif (graceFinished){\n    // final aufräumen\n    flow.set(\"storage_grace_until\", 0);\n    flow.set(\"storage_grace_mode250\", false);\n    flow.set(\"storage_active\", false);\n\n    mqttOutArr.push(\n        mqttMsg(\"marstek/venus_e/stat/storage_info\",\n                `storage:done target=${targetSoc}% grace-finished`),\n        mqttMsg(\"marstek/storage/stat/enable\",\"OFF\"),\n        mqttMsg(\"marstek/venus_e/stat/mode\",\"Passive\")\n    );\n\n    setStatus(\"grey\",\"dot\",\"Lagerung fertig (Grace zu Ende)\");\n    return [\n        udpOutArr.length ? udpOutArr : null,\n        mqttOutArr.length ? mqttOutArr : null\n    ];\n}\n\n// CASE B: Wir sind in Grace (Nachlaufphase halten auf Ziel-SoC)\n// ------------------------------------------------------------\nif (inGrace){\n    const secLeft = Math.round((graceUntil - now)/1000);\n\n    if (modeLower === \"manual\"){\n        // Alles gut, Gerät lädt/ hält gerade.\n        setStatus(\"blue\",\"dot\",`Grace läuft ${secLeft}s (-250W hold)`);\n\n        // Nur Info-Publish, damit wir Verlauf sehen\n        mqttOutArr.push(\n            mqttMsg(\"marstek/venus_e/stat/storage_info\",\n                    `storage:grace-hold mode=${modeRaw} t_left=${secLeft}s`)\n        );\n\n        return [\n            udpOutArr.length ? udpOutArr : null,\n            mqttOutArr.length ? mqttOutArr : null\n        ];\n    } else {\n        // Gerät ist aus Manual rausgefallen (z.B. Passive).\n        // Während Grace: sofort zurück auf Manual(-250W)\n        const cmdManual250 = buildManualCmd(POWER_GRACE_HOLD_W);\n        udpOutArr.push({\n            payload: Buffer.from(JSON.stringify(cmdManual250),\"utf8\")\n        });\n\n        mqttOutArr.push(\n            mqttMsg(\"marstek/venus_e/stat/storage_info\",\n                    `storage:grace-reassert -> Manual(${POWER_GRACE_HOLD_W}W) from ${modeRaw} t_left=${secLeft}s`),\n            mqttMsg(\"marstek/venus_e/stat/mode\",\"Manual\")\n        );\n\n        setStatus(\"blue\",\"ring\",`Grace reassert (-250W) ${secLeft}s left`);\n\n        return [\n            udpOutArr.length ? udpOutArr : null,\n            mqttOutArr.length ? mqttOutArr : null\n        ];\n    }\n}\n\n// CASE A: Wir sind VOR Grace (Lagerung aktiv, Ziel-SoC noch nicht erreicht)\n// ------------------------------------------------------------------------\n// storageActive sollte hier true sein, graceUntil kann 0 sein, oder >now aber graceMode250==false\n// Wichtig: Anders als in v3 brechen wir NICHT mehr sofort ab,\n// sondern wir forcen weiterhin Manual(-500W), solange storage_active==true.\n\nif (storageActive && !inGrace){\n    if (modeLower === \"manual\"){\n        // Alles normal, wir laden gerade mit -500W (vom Start-Lagerung Node gesetzt)\n        setStatus(\"green\",\"dot\",`Lagerung aktiv (<target ${targetSoc}%)`);\n        return null;\n    } else {\n        // Gerät hat sich z.B. auf Passive gestellt obwohl wir noch nicht am Ziel sind.\n        // Jetzt NICHT abbrechen, sondern wieder hochziehen auf Manual(-500W),\n        // weil du Lagerung bewusst aktiv gelassen hast.\n        const cmdManual500 = buildManualCmd(POWER_PRE_GRACE_W);\n        udpOutArr.push({\n            payload: Buffer.from(JSON.stringify(cmdManual500),\"utf8\")\n        });\n\n        mqttOutArr.push(\n            mqttMsg(\"marstek/venus_e/stat/storage_info\",\n                    `storage:reassert-pregrace -> Manual(${POWER_PRE_GRACE_W}W) from ${modeRaw}`),\n            mqttMsg(\"marstek/venus_e/stat/mode\",\"Manual\")\n        );\n\n        setStatus(\"green\",\"ring\",\"pre-grace reassert -500W\");\n        return [\n            udpOutArr.length ? udpOutArr : null,\n            mqttOutArr.length ? mqttOutArr : null\n        ];\n    }\n}\n\n// Fallback (sollte kaum noch erreicht werden)\nsetStatus(\"grey\",\"ring\",\"no-op\");\nreturn null;\n","outputs":2,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":950,"y":720,"wires":[["82cd8fd8b98bb7dd"],["eb14eb2e1b2fc555"]]},{"id":"84fdc643b39d1f50","type":"function","z":"2323a58d30747a1f","name":"cache mode in flow","func":"// speichert letzten bekannten Modus fürs Watchdog\nflow.set('mode', String(msg.payload || '').trim());\nreturn null;","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":910,"y":660,"wires":[[]]},{"id":"e5740d2a03aecce6","type":"function","z":"2323a58d30747a1f","name":"cache vgrid in flow","func":"// merkt sich ongrid_power (Netzleistung / Einspeisung) fürs Watchdog\n// erwartet payload z.B. aus marstek/venus_e/stat/ongrid_power\nconst n = Number(msg.payload);\nif (!Number.isNaN(n)) {\n    flow.set('vgrid', n);\n}\nreturn null;","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":910,"y":840,"wires":[[]]},{"id":"f75f084078fadfb9","type":"mqtt in","z":"2323a58d30747a1f","name":"listen: ongrid_power → cache vgrid","topic":"marstek/venus_e/stat/ongrid_power","qos":"0","datatype":"auto","broker":"22f544be.780a3c","nl":false,"rap":true,"rh":0,"inputs":0,"x":380,"y":840,"wires":[["e5740d2a03aecce6"]]},{"id":"ad0f6e6be66a0a2c","type":"link in","z":"2323a58d30747a1f","name":"link in 1","links":["440e29182b3a25eb","82cd8fd8b98bb7dd"],"x":1695,"y":220,"wires":[["cd046bbca44b1231"]]},{"id":"440e29182b3a25eb","type":"link out","z":"2323a58d30747a1f","name":"link out 11","mode":"link","links":["ad0f6e6be66a0a2c"],"x":1755,"y":1060,"wires":[]},{"id":"82cd8fd8b98bb7dd","type":"link out","z":"2323a58d30747a1f","name":"link out 12","mode":"link","links":["ad0f6e6be66a0a2c"],"x":1755,"y":420,"wires":[]},{"id":"5d8137bf164324ad","type":"inject","z":"2323a58d30747a1f","name":"alle 10s prüfen","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"10","once":true,"onceDelay":"5","topic":"","payloadType":"date","x":320,"y":780,"wires":[["dd2c3f363866bdb2"]]},{"id":"dd2c3f363866bdb2","type":"function","z":"2323a58d30747a1f","name":"Watchdog: Passive prüfen + UDP Manual0→Passive Reset + MQTT + Log (v2.5)","func":"// ===== Watchdog v2.5 =====\n// Erkennt festhängenden 'Passive'-Modus (Einspeisung aktiv)\n// → Schickt über UDP erst Manual0, dann 10 s später wieder Passive\n// → Publiziert MQTT-Event + schreibt Logzeile in marstek.log\n\nconst MAX_PASSIVE_TIME_MS = 60000;   // 60 s im Passive-Modus\nconst VGRID_MIN_W = 50;              // min. Leistung die nicht 0 ist\nconst VGRID_MAX_W = 250;             // max. Leistung im Fehlerbild\nconst COOLDOWN_MS = 180000;          // 3 min Ruhe nach letztem Fix\nconst RESET_DELAY_MS = 10000;        // 10 s warten vor Rückschalten auf Passive\n\nlet mode      = flow.get('mode');\nlet vgrid     = flow.get('vgrid');\nlet enteredAt = flow.get('wd_last_passive') || 0;\nlet lastFix   = flow.get('wd_last_fix') || 0;\nconst now     = Date.now();\n\nnode.status({\n    fill: 'grey',\n    shape: 'dot',\n    text: `mode=${mode || '—'} | vgrid=${(vgrid !== undefined) ? vgrid : '—'}`\n});\n\nif (mode === 'Passive') {\n    if (!enteredAt) {\n        enteredAt = now;\n        flow.set('wd_last_passive', enteredAt);\n    }\n} else {\n    if (enteredAt) {\n        flow.set('wd_last_passive', 0);\n    }\n    return null;\n}\n\nconst passiveDuration = now - enteredAt;\nconst cooldownOK      = (now - lastFix) >= COOLDOWN_MS;\nconst looksWrong = (\n    typeof vgrid === 'number' &&\n    vgrid >= VGRID_MIN_W &&\n    vgrid <= VGRID_MAX_W\n);\nconst longEnough = passiveDuration >= MAX_PASSIVE_TIME_MS;\n\nif (looksWrong && longEnough && cooldownOK) {\n    function buildModeCmd(which) {\n        if (which === 'Manual0') {\n            return {\n                id: 912,\n                method: 'ES.SetMode',\n                params: {\n                    id: 0,\n                    config: {\n                        mode: 'Manual',\n                        manual_cfg: {\n                            time_num: 1,\n                            start_time: '00:00',\n                            end_time: '23:59',\n                            week_set: 127,\n                            power: 0,\n                            enable: 1\n                        }\n                    }\n                }\n            };\n        }\n        return {\n            id: 913,\n            method: 'ES.SetMode',\n            params: {\n                id: 0,\n                config: {\n                    mode: 'Passive',\n                    passive_cfg: {\n                        power: 0,\n                        cd_time: 300\n                    }\n                }\n            }\n        };\n    }\n\n    const udpManual0 = {\n        payload: Buffer.from(JSON.stringify(buildModeCmd('Manual0')), 'utf8')\n    };\n    const udpPassive = {\n        payload: Buffer.from(JSON.stringify(buildModeCmd('Passive')), 'utf8')\n    };\n\n    const eventText = `WATCHDOG: Forced UDP Manual0→Passive reset (vgrid=${Math.round(vgrid)}W after ${(passiveDuration/1000).toFixed(1)}s Passive)`;\n    const logLine   = `[${new Date().toISOString()}] ${eventText}`;\n\n    const mqttMsgNow = {\n        topic: 'marstek/venus_e/stat/watchdog_event',\n        payload: logLine\n    };\n    const fileMsgNow = {\n        payload: logLine\n    };\n\n    flow.set('wd_last_fix', now);\n\n    node.status({\n        fill: 'yellow',\n        shape: 'ring',\n        text: `Manual0 jetzt, Passive in 10s (${Math.round(vgrid)}W)`\n    });\n\n    node.send([[udpManual0], [mqttMsgNow], [fileMsgNow]]);\n\n    setTimeout(() => {\n        const mqttMsgLater = {\n            topic: 'marstek/venus_e/stat/watchdog_event',\n            payload: `[${new Date().toISOString()}] WATCHDOG: switched back to Passive after Manual0 hold`\n        };\n        node.send([[udpPassive], [mqttMsgLater], null]);\n    }, RESET_DELAY_MS);\n\n    return null;\n}\n\nreturn null;","outputs":3,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":1110,"y":780,"wires":[["82cd8fd8b98bb7dd"],["eb14eb2e1b2fc555"],["4c3a0daf83b2177d"]]},{"id":"a44b197f59436b03","type":"function","z":"2323a58d30747a1f","name":"Start Lagerung: Manual → Ziel 50 %","func":"// Lagerungsbetrieb Handler (Schalter marstek/storage/cmnd/enable)\n// ON  => Lagerung aktiv: storage_active=true, storage_target setzen, sofort Manual mit POWER_W (-500W Schnellladen)\n// OFF => Lagerung AUS: storage_active=false, sofort Manual0, dann Passive nach 1s\n//      Außerdem publishen wir saubere States nach MQTT.\n//\n// NEU für Grace-Logik mit -250W halten:\n// - Diese Funktion kümmert sich NUR um Start/Stop durch den Button.\n// - Die eigentliche Grace-Phase (sanft halten mit -250W) macht der Watcher-Node.\n\nconst wantRaw = String(msg.payload || '').trim().toUpperCase();\nconst wantOn = (wantRaw === 'ON');\n\nconst TARGET_SOC       = 50;    // % Abschaltziel\nconst FAST_POWER_W     = -500;  // Schnell-Ladeleistung im eigentlichen Lagerungsmodus (vor Grace)\n\nfunction buildSetModeManual(powerW) {\n    return {\n        id: 700,\n        method: 'ES.SetMode',\n        params: {\n            id: 0,\n            config: {\n                mode: 'Manual',\n                manual_cfg: {\n                    time_num: 1,\n                    start_time: '00:00',\n                    end_time: '23:59',\n                    week_set: 127,\n                    power: powerW,\n                    enable: 1\n                }\n            }\n        }\n    };\n}\nfunction buildSetModeManual0() {\n    return buildSetModeManual(0);\n}\nfunction buildSetModePassive() {\n    return {\n        id: 913,\n        method: 'ES.SetMode',\n        params: {\n            id: 0,\n            config: {\n                mode: 'Passive',\n                passive_cfg: {\n                    power: 0,\n                    cd_time: 300\n                }\n            }\n        }\n    };\n}\n\nconst udpArr = [];\nconst mqttArr = [];\n\nfunction pushEnableState(onBool){\n    mqttArr.push({\n        topic:'marstek/storage/stat/enable',\n        payload:onBool ? 'ON':'OFF'\n    });\n}\nfunction pushStorageInfo(txt){\n    mqttArr.push({\n        topic:'marstek/venus_e/stat/storage_info',\n        payload:txt\n    });\n}\nfunction pushModeOptimistic(mode){\n    mqttArr.push({\n        topic:'marstek/venus_e/stat/mode',\n        payload:mode\n    });\n}\n\nif (wantOn) {\n    // === Lagerung einschalten ===\n    flow.set('storage_active', true);              // Lagerung läuft jetzt\n    flow.set('storage_target', TARGET_SOC);\n    flow.set('storage_grace_until', 0);            // Grace ist NOCH NICHT aktiv\n    flow.set('storage_grace_mode250', false);      // wir sind noch im Schnellladen (-500W)\n\n    node.status({\n        fill:'green',\n        shape:'dot',\n        text:`Lagerung aktiv (Ziel ${TARGET_SOC}%)`\n    });\n\n    // Sofort auf Manual mit FAST_POWER_W (-500W)\n    const cmdManualFast = buildSetModeManual(FAST_POWER_W);\n    udpArr.push({\n        payload:Buffer.from(JSON.stringify(cmdManualFast),'utf8')\n    });\n\n    pushStorageInfo(`storage:start target=${TARGET_SOC}% power=${FAST_POWER_W}W`);\n    pushModeOptimistic('Manual');\n    pushEnableState(true);\n\n} else {\n    // === Lagerung manuell ausschalten ===\n    flow.set('storage_active', false);\n    flow.set('storage_grace_until', 0);\n    flow.set('storage_grace_mode250', false);\n\n    node.status({\n        fill:'grey',\n        shape:'ring',\n        text:'Lagerung aus'\n    });\n\n    // Erst Manual0 (0W halten, sauber aus dem Ladeprofil raus)\n    const cmdManual0 = buildSetModeManual0();\n    udpArr.push({\n        payload:Buffer.from(JSON.stringify(cmdManual0),'utf8')\n    });\n\n    // Publish sofort OFF und Passive als Zielzustand\n    pushStorageInfo('storage:abort via switch OFF');\n    pushModeOptimistic('Passive');\n    pushEnableState(false);\n\n    // nach 1s wirklich auf Passive schalten\n    setTimeout(()=>{\n        const cmdPassive = buildSetModePassive();\n        node.send([\n            [{payload:Buffer.from(JSON.stringify(cmdPassive),'utf8')}],\n            [{topic:'marstek/venus_e/stat/mode',payload:'Passive'}]\n        ]);\n    },1000);\n}\n\n// nach 400ms nochmal ES.GetMode pollen\nsetTimeout(()=>{\n    const getCmd = {\n        id:320,\n        method:'ES.GetMode',\n        params:{id:0}\n    };\n    node.send([\n        [{payload:Buffer.from(JSON.stringify(getCmd),'utf8')}],\n        null\n    ]);\n},400);\n\nreturn [udpArr,mqttArr];\n","outputs":2,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":970,"y":540,"wires":[["82cd8fd8b98bb7dd"],["eb14eb2e1b2fc555"]]},{"id":"0ec8eee2102c62b8","type":"function","z":"2323a58d30747a1f","name":"Watcher: bei ≥50 % → Passive","func":"// ===== Watcher mit Grace-Phase (-250W halten) =====\n//\n// Eingänge: SoC Updates (bat_soc oder es_bat_soc)\n// Ziele:\n// 1. Wenn Lagerung aktiv (storage_active=true) und SoC >= target:\n//    -> Grace starten:\n//         - storage_grace_until = now + graceDurationMs\n//         - storage_grace_mode250 = true\n//         - Gerät SOFORT auf Manual mit -250W setzen\n//         - MQTT \"grace-start\"\n//         - Node-Status gelb (\"Nachlauf ...\")\n//    Während Grace:\n//         - storage_active bleibt TRUE\n//         - alle SoC-Updates checken:\n//              * Wenn Grace noch läuft:\n//                    - falls Modus NICHT Manual oder Leistung nicht -250W\n//                      -> erneut Manual(-250W) schicken + MQTT 'grace-hold reassert'\n//              * Wenn Grace abgelaufen ODER SoC >= target+1:\n//                    -> final abschalten:\n//                          storage_active=false\n//                          storage_grace_until=0\n//                          storage_grace_mode250=false\n//                          auf Passive schalten\n//                          MQTT \"storage:done\", mode=Passive, storage/stat/enable=OFF\n//                          Node-Status blau\n//\n// 2. Wenn Lagerung aktiv aber SoC < target und Grace noch NICHT gestartet:\n//    -> Schnellladephase (-500W) läuft weiter; nichts tun.\n//\n// Wichtig: Winter-Controller bleibt komplett blockiert solange storage_active===true.\n// D.h. auch während Grace bleibt storage_active TRUE, damit Wintercontroller nix sendet.\n//\n// Konstanten:\nconst graceDurationMs   = 5 * 60 * 1000; // 5 Minuten Nachlauf\nconst HOLD_POWER_W      = -250;          // sanftes Halten in Grace\nconst FINAL_MODE        = 'Passive';     // Ziel nach Grace\n// Hinweis: Schnellladeleistung (-500W) wird im anderen Node gesetzt.\n\nfunction buildManual(powerW) {\n    return {\n        id: 800,\n        method: 'ES.SetMode',\n        params: {\n            id: 0,\n            config: {\n                mode: 'Manual',\n                manual_cfg: {\n                    time_num: 1,\n                    start_time: '00:00',\n                    end_time: '23:59',\n                    week_set: 127,\n                    power: powerW,\n                    enable: 1\n                }\n            }\n        }\n    };\n}\n\nfunction buildPassiveCmd() {\n    return {\n        id: 801,\n        method: 'ES.SetMode',\n        params: {\n            id: 0,\n            config: {\n                mode: 'Passive',\n                passive_cfg: {\n                    power: 0,\n                    cd_time: 300\n                }\n            }\n        }\n    };\n}\n\nconst socNow = Number(msg.payload);\nif (Number.isNaN(socNow)) return null;\n\nconst active           = flow.get('storage_active')        || false;\nconst target           = flow.get('storage_target')        || 50;\nlet   graceUntil       = flow.get('storage_grace_until')   || 0;\nlet   graceMode250     = flow.get('storage_grace_mode250') || false;\nconst now              = Date.now();\n\nif (!active) {\n    // Lagerung ist gar nicht aktiv -> nix tun\n    return null;\n}\n\n// MQTT-Sammelarray\nconst mqttMsgs = [];\n// UDP-Sammelarray (kann leer bleiben, außer wir schicken Manual(-250) oder Passive)\nconst udpMsgs  = [];\n\n// === FALL A: Noch keine Grace, aber Ziel-SOC erreicht/überschritten ===\nif (!graceUntil && socNow >= target) {\n    // Grace starten\n    graceUntil   = now + graceDurationMs;\n    graceMode250 = true;\n\n    flow.set('storage_grace_until',   graceUntil);\n    flow.set('storage_grace_mode250', graceMode250);\n\n    // Während der Grace bleibt storage_active TRUE,\n    // damit der Wintercontroller draußen bleibt und wir weiter steuern dürfen.\n\n    node.status({\n        fill: 'yellow',\n        shape: 'dot',\n        text: `Nachlauf aktiv @${socNow}% (bis ${new Date(graceUntil).toLocaleTimeString()})`\n    });\n\n    // Sofort umschalten auf Manual mit HOLD_POWER_W (-250W)\n    const cmdManualHold = buildManual(HOLD_POWER_W);\n    udpMsgs.push({\n        payload: Buffer.from(JSON.stringify(cmdManualHold),'utf8')\n    });\n\n    mqttMsgs.push({\n        topic: 'marstek/venus_e/stat/storage_info',\n        payload: `storage:grace-start soc=${socNow}% target=${target}% holdUntil=${graceUntil} holdPower=${HOLD_POWER_W}W`\n    });\n\n    // Optimistischer Mode -> \"Manual\"\n    mqttMsgs.push({\n        topic: 'marstek/venus_e/stat/mode',\n        payload: 'Manual'\n    });\n\n    return [udpMsgs, mqttMsgs];\n}\n\n// Ab hier: Grace läuft ODER lief schon\nconst graceRunning   = (!!graceUntil && now < graceUntil);\nconst graceExpired   = (!!graceUntil && now >= graceUntil);\nconst socHighEnough  = (socNow >= (target + 1));\n\n// === FALL B: Grace läuft noch ===\nif (graceRunning) {\n    // Wir wollen sicherstellen, dass das Gerät weiter lädt mit HOLD_POWER_W.\n    // Falls die Kiste zwischendurch auf Passive gefallen ist, drücken wir wieder Manual(-250W).\n    //\n    // Dafür schicken wir bei JEDEM SoC-Update einfach nochmal Manual(-250W).\n    // Das ist simpel, idempotent, und stellt sicher dass die Kiste nicht wegschaltet.\n\n    const cmdManualHold = buildManual(HOLD_POWER_W);\n    udpMsgs.push({\n        payload: Buffer.from(JSON.stringify(cmdManualHold),'utf8')\n    });\n\n    mqttMsgs.push({\n        topic: 'marstek/venus_e/stat/storage_info',\n        payload: `storage:grace-hold soc=${socNow}% mode=Manual holdPower=${HOLD_POWER_W}W until=${graceUntil}`\n    });\n\n    // Status: gelber Ring (wir sind in der Haltephase)\n    node.status({\n        fill: 'yellow',\n        shape: 'ring',\n        text: `Grace hält @${socNow}% bis ${new Date(graceUntil).toLocaleTimeString()} (-250W)`\n    });\n\n    // storage_active BLEIBT true bis Grace vorbei,\n    // damit Wintercontroller komplett blockiert bleibt.\n    return [udpMsgs, mqttMsgs];\n}\n\n// === FALL C: Grace ist vorbei ODER SoC ist eh schon >= target+1 ===\nif (graceExpired || socHighEnough) {\n\n    // Jetzt wirklich final abschalten:\n    flow.set('storage_active', false);\n    flow.set('storage_grace_until', 0);\n    flow.set('storage_grace_mode250', false);\n\n    node.status({\n        fill: 'blue',\n        shape: 'dot',\n        text: `Ziel erreicht (${socNow}%) → Passive`\n    });\n\n    // UDP: auf Passive umschalten\n    const cmdPassive = buildPassiveCmd();\n    udpMsgs.push({\n        payload: Buffer.from(JSON.stringify(cmdPassive),'utf8')\n    });\n\n    // MQTT: melden dass wir fertig sind\n    mqttMsgs.push(\n        {\n            topic: 'marstek/venus_e/stat/storage_info',\n            payload: `storage:done soc=${socNow}% -> Passive (grace end)`\n        },\n        {\n            topic: 'marstek/venus_e/stat/mode',\n            payload: FINAL_MODE\n        },\n        {\n            topic: 'marstek/storage/stat/enable',\n            payload: 'OFF'\n        }\n    );\n\n    return [udpMsgs, mqttMsgs];\n}\n\n// Falls wir hierher kommen, heißt das:\n// - storage_active=true\n// - Grace existiert (graceUntil gesetzt)\n// - aber weder running noch expired? (Theoretisch nicht möglich, aber fallback)\nreturn null;\n","outputs":2,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":950,"y":600,"wires":[["82cd8fd8b98bb7dd"],["eb14eb2e1b2fc555"]]},{"id":"522a6073a4de3aa9","type":"link out","z":"2323a58d30747a1f","name":"link out 14","mode":"link","links":["b0a5093f43411d49"],"x":535,"y":200,"wires":[]},{"id":"b0a5093f43411d49","type":"link in","z":"2323a58d30747a1f","name":"link in 2","links":["522a6073a4de3aa9"],"x":255,"y":360,"wires":[["413441b26fcbd76b"]]},{"id":"c306c93706c41414","type":"link in","z":"2323a58d30747a1f","name":"send -> marstek.log","links":["2a278b0892f5d734","4c3a0daf83b2177d"],"x":255,"y":1860,"wires":[["0a9a4d91bcf5abfb"]]},{"id":"2a278b0892f5d734","type":"link out","z":"2323a58d30747a1f","name":"send -> marstek.log","mode":"link","links":["c306c93706c41414"],"x":1755,"y":1260,"wires":[]},{"id":"4c3a0daf83b2177d","type":"link out","z":"2323a58d30747a1f","name":"send -> marstek.log","mode":"link","links":["c306c93706c41414"],"x":1755,"y":800,"wires":[]},{"id":"22f544be.780a3c","type":"mqtt-broker","name":"HomeAssistant-MQTT","broker":"10.100.1.90","port":"1883","clientid":"NodeRed","autoConnect":true,"usetls":false,"compatmode":false,"protocolVersion":"4","keepalive":"60","cleansession":true,"autoUnsubscribe":true,"birthTopic":"","birthQos":"0","birthPayload":"","birthMsg":{},"closeTopic":"","closeQos":"0","closePayload":"","closeMsg":{},"willTopic":"","willQos":"0","willPayload":"","willMsg":{},"userProps":"","sessionExpiry":""},{"id":"57c7572eb86c50c7","type":"influxdb","hostname":"127.0.0.1","port":"8086","protocol":"http","database":"nodered","name":"NodeRed DB","usetls":false,"tls":"","influxdbVersion":"1.x","url":"http://localhost:8086","timeout":"","rejectUnauthorized":true}]
